-- Ссылки
	http://www.sql.ru/articles/mssql/2005/073102partitionedtablesandindexes.shtml
	http://www.cyberguru.ru/database/sqlserver/sqlserver2005-partitioned-tables-indexes-page12.html
	https://msdn.microsoft.com/ru-ru/library/ms188730.aspx
	https://technet.microsoft.com/ru-ru/library/ms191174(v=sql.105).aspx
	https://www.brentozar.com/sql/table-partitioning-resources/
	

-- Основное
	- partitioning is mostly for improved maintenance, fast loads, fast deletes and the ability to spread a table across multiple filegroups; it is not primarily for query performance.
	- В SQL Server все таблицы и индексы в базе данных считаются секционированными, даже если они состоят всего лишь из одной секции. Фактически, секции представляют собой базовую организационную единицу в физической архитектуре таблиц и индексов. Это означает, что логическая и физическая архитектура таблиц и индексов, включающая несколько секций, полностью отражает архитектуру таблиц и индексов, состоящих из одной секции
	- Секционирование происходит на уровне файловых группа, а не файлов	
	- При включении секционирования, вы лишаетесь всех онлайн операций  (перестроение PK, вроде только это), но только до 2012
	- Статистика большая головная боль на таких таблицах. При появлении новой партиции и добавлении туда некоторого количества данных, SQL Server ещё не сделал для неё статистику и запрос может начать работать мало	
	
-- Вспомогательные Таблицы
	- что хранится в партициях индексов
		sys.system_internals_allocation_units

-- Виды секционирования
	- https://www.simple-talk.com/content/article.aspx?article=1587
	-- Секционированные таблицы ()
		- Доступно только в Enterprise
		- Когда переносим секции между файловыми группами, накладывается эксклюзивная блокировка
		- Для клиента всё прозрачно
		- Общая статистика на всю таблицу
		- Нет поддержки online пересоздания индексов
		- Поддержка репликации
		- Максимально 1000/15000 секций
		- Столбец секционирования присутствует (добавляется) в кластерном и некластерном индексе. Увеличивает объём данных
		- Изменение планов выполнения запросов

	-- Секционированные представления
		- Доступно в любой версии сервера
		- Максимально 255 таблиц/секций
		- Создаём физически таблицы на каждое представление путём CONSTRAINT
		- Чтение данных происходит из представления, оптимизатор будет знать, в какой таблице находятся эти данные
		- Для записи, можно сделать представление обновляемым или клиент должен знать куда писать
		- Мы можем переносить таблицы/секции в разные файловые группы, оставляя доступным систему
		 (но для этого надо иметь кластерные индексы вместо первичных ключей) (только Enterprise Edition)
		- Можем иметь разные схемы компресии и иного
		- Статистика на уровне таблиц
		- Схемы и индексы могут отличаться на уровне таблиц
		- Online пересоздания индекса (Enterprise)
		- Проблемы с поддержкой репликации. При добавлении новой таблицы, нужно менять схему репликации
		- Возможно придётся поменять кластерный ключ если сипользуется 1 представление на несколько таблиц
		
	-- Комбинирование
		- Года выделять не в отдельные БД, а в отдельные таблицы. А сами года разделить секционированием
		
	-- Федерации
		- Стараться чтобы нужные данные находились на сервере, к которому обращаются (правило 80/20) или хотя бы 50/50
		- Create Federation - терминалогия SQL Azure
		
	-- Несколько фильтров (колонок)
		1. Секционируем базовую таблицу по одному ключу
		2. Создаём VIEW, индекс по ней и выбираем другой ключ
	
-- Причины секционировать
	- Таблица содержит (или может в будущем накопить) множество данных, используемых различными способами.
	- Запросы или обновления таблицы выполняются не так, как ожидалось, либо затраты на обслуживание превышают прогнозируемые периоды технического обслуживания.
	
-- Преимущества
	1. Использование секций может помочь улучшить производительность репликации транзакций и репликации слиянием, эффективно сокращая объем данных и метаданных, обрабатываемых системой репликации
	2. Секционирование таблицы или индекса может улучшить производительность запросов, если оно правильно рассчитано и спроектировано с учетом типов часто выполняемых запросов и конфигурации оборудования. 
	2. Возможность разделить нагрузку OLTP/Аналитика/Отчёты по FG
	3. Не приходится обслуживать старые данные. 
	4. Нет смысла в постоянном архивировании старых данных
	5. Можно восстановить OLTP FG, дать доступ людям и заниматься восстановлением архивной части
	6. Автоматическое обновление статистики. При 20% изменений, архивные данные меняются редко и не будет автоматического обновления статистики
	
-- Недостатки
	1. Сложность разработки, оптимизации, поддерживания
	2. В теории вся система была написана без учёта секционирования и надо протестировать все запросы после применения секционирования
	3. В момент разбиения данных по секциям, система будет недоступна
	4. Требуется Enterprise версию сервера
	5. Сильно ухудшаются запросы типа MIX/MAX
		- Решением может быть CROSS APPLY или UNION ALL каждой партиции
		
	
-- Особенности:
	1. Обычно имеет смысл спроектировать секционированную таблицу, а уже затем создать индекс для нее. В таком случае сервер SQL Server автоматически разбивает индекс на секции на основе той же схемы и столбца секционирования, что используются для таблицы. В результате индекс секционируется в основном таким же образом, как и таблица, что делает его выровненным относительно таблицы.
	2. Создание невыровненного (независимо от базовой таблицы) секционированного индекса может оказаться эффективным в следующих случаях:
		- Базовая таблица не секционирована.
		- Ключ индекса является уникальным и не содержит столбца секционирования таблицы.
		- Требуется участие базовой таблицы в выровненных соединениях с таблицами, использующими другие столбцы соединения.
	3. При секционировании уникального индекса (кластеризованного или некластеризованного) столбец секционирования необходимо выбирать из столбцов, участвующих в ключе уникального индекса.
	4. При секционировании кластеризованного индекса столбец секционирования должен содержаться в ключе кластеризации. При секционировании неуникального кластеризованного индекса, если столбец секционирования не указан явно в ключе кластеризации, SQL Server по умолчанию добавляет столбец секционирования в список ключей кластеризованного индекса.
	5. Ограничения оперативной памяти могут повлиять на производительность SQL Server при построении секционированного индекса и даже на саму возможность его построения. Такое случается, например, когда индекс не выровнен со своей базовой таблицей или со своим кластеризованным индексом, если такой существует в таблице. Чем больше число секций, тем больше требуется оперативной памяти. Как для выровненных, так и для невыровненных индексов может потребоваться больший объем оперативной памяти, если SQL Server применяет степени параллелизма для выполнения данной операции на многопроцессорном компьютере
	6. В таблице должна быть пустая секция, в которую будут записываться новые данные
	7. Обратите внимание, что любые индексы, не выровненные по представляемым таблицам, должны быть удалены или отключены до переключения секций. Однако после переключения их можно создать повторно. 
	8. SQL Server 2016 поддерживает по умолчанию до 15 000 секций. В версиях, предшествующих SQL Server 2012, количество секций ограничивалось 1000 по умолчанию. В системах x86 создание таблицы или индекса с числом секций более 1000 возможно, но не поддерживается.
	9. Чтобы добиться максимальной производительности с помощью параллельных операций, рекомендуется, чтобы число секций и процессорных ядер совпадало. но не превышало 64 (это максимальное число параллельных процессоров, которые SQL Server может использовать).
	10. При большом количестве используемых секций рекомендуется использовать ОЗУ не менее 16 ГБ
	11. Указывайте диапазоны, которые не выходят за границы секций. Например не < 200, а <= 199
	12. Указать конкретную партицию AND $PARTITION.PF(RowID) = 2;
	
-- Создание секционирования:
	1. Сначала создаём Функции секционирования
		- У таблиц может быть не более 1000 секций.
	2. Схемы секционирования
	3. При секционировании лучше указывать CONSTRAINT, чтобы помогать оптимизатору
	
-- Перенос секции из таблицы в таблицу
	1. Одинаковая схема
	2. В таблице назначения должна быть пуская секция
	
	- Путем добавления таблицы в качестве секции в уже существующую секционированную таблицу.
	- Путем переключения секции из одной секционированной таблицы в другую.
	- Путем удаления секции для создания единой таблицы.
	
-- Index/Индексы
	- Можно секционировать отдельно индексы, без таблицы
	- Если строить выровненный индекс, тогда потребуется объём оперативной памяти будет равен объёму 1 секции
	- Если строить невыровненный индекс, тогда потребуется объём оперативной памяти равный размеру всей таблицы
	- Если строить всё вышеперечисленной с параллелизмом, то потребуется память умноженная на количество потоков
	
-- Конструкции
	- CREATE PARTITION FUNCTION as RANGE right/right for values:
		- Указывает, к какой области интервала значений принадлежит аргумент boundary_value [ ,...n ] (к левой или правой) для случая, когда значения интервалов были отсортированы компонентом Компонент Database Engine по возрастанию слева направо.
		- По-умолчfнию LEFT	

-- *** Пример ***
	- Сначала создаём файловые группы и файлы
	CREATE PARTITION FUNCTION pfOrders2011(datetime2(0))
	as RANGE right for values
	(
		'2011-02-01','2011-03-01'...,'2011-12-01'
	)

	CREATE PARTITION scheme psOrders2011
	as PARTITION pfOrders2011
	all to ([Data2011])  -- Файловая группа
	
	-- После создания функции и схемы, создаём таблицу с привязкой к ним
		CREATE TABLE par (part int, num int, gp int) ON psOrders2011 (part)
	
	-- CREATE Creates a partition function called myRangePF1 that will partition a table into four partitions
	CREATE PARTITION FUNCTION myRangePF1 (int)
		AS RANGE LEFT FOR VALUES (1, 100, 1000,5000) ;
	GO
	-- Creates a partition scheme called myRangePS1 that applies myRangePF1 to the four filegroups created above
	CREATE PARTITION SCHEME myRangePS1
		AS PARTITION myRangePF1
		TO (test1fg, test2fg, test3fg, test4fg,[PRIMARY]) ;
	GO

	-- Добавление новой секции происходит поочерёдно. Добавление порога в функцию происходит только в NEXT USED схему

	ALTER PARTITION SCHEME myRangePS1
		NEXT USED test5fg;
		
	ALTER PARTITION FUNCTION myRangePF1 ()
	SPLIT RANGE (50000);
	
-- Можно разбить данные через CONSTRAINT и разные таблицы, а работать с VIEW

	CREATE TABLE Orders2011
	(
		OrderId int not null,
		OrderDate datetime2(0) not null
		...
		constraint CHK_Orders2011_Final
		check(OrderDate >= '2011-01-01' AND OrderDate < '2012-01-01')
	)
	ON [Data2011]	
		
	- Чтобы переместить данные из оперативных в архивные, сначала пересоздаём индеексы на архивной файловой группе
	
-- Проверка на наличие секционирования в таблице
	SELECT *   
	FROM sys.tables AS t   
	JOIN sys.indexes AS i   
		ON t.[object_id] = i.[object_id]   
		--AND i.[type] IN (0,1)   
	JOIN sys.partition_schemes ps   
		ON i.data_space_id = ps.data_space_id   
	WHERE t.name = 'TableName';   
	
-- Определение граничных значений для секционированной таблицы
	SELECT t.name AS TableName, i.name AS IndexName, p.partition_number, p.partition_id, i.data_space_id, f.function_id, f.type_desc, r.boundary_id, r.value AS BoundaryValue   
	FROM sys.tables AS t  
	JOIN sys.indexes AS i  
		ON t.object_id = i.object_id  
	JOIN sys.partitions AS p  
		ON i.object_id = p.object_id AND i.index_id = p.index_id   
	JOIN  sys.partition_schemes AS s   
		ON i.data_space_id = s.data_space_id  
	JOIN sys.partition_functions AS f   
		ON s.function_id = f.function_id  
	LEFT JOIN sys.partition_range_values AS r   
		ON f.function_id = r.function_id and r.boundary_id = p.partition_number  
	WHERE t.name = 'TableName' AND i.type <= 1  
	ORDER BY p.partition_number;
	
-- Определение столбца секционирования секционированной таблицы
	SELECT   
		t.[object_id] AS ObjectID   
		, t.name AS TableName   
		, ic.column_id AS PartitioningColumnID   
		, c.name AS PartitioningColumnName   
	FROM sys.tables AS t   
	JOIN sys.indexes AS i   
		ON t.[object_id] = i.[object_id]   
		AND i.[type] <= 1 -- clustered index or a heap   
	JOIN sys.partition_schemes AS ps   
		ON ps.data_space_id = i.data_space_id   
	JOIN sys.index_columns AS ic   
		ON ic.[object_id] = i.[object_id]   
		AND ic.index_id = i.index_id   
		AND ic.partition_ordinal >= 1 -- because 0 = non-partitioning column   
	JOIN sys.columns AS c   
		ON t.[object_id] = c.[object_id]   
		AND ic.column_id = c.column_id   
	WHERE t.name = 'par';
	
-- Найти партицию для строки 
	SELECT $PARTITION.[partition_function](patition_column) AS Partition,* FROM ...
	
	
-- ***** Дмитрий Короткевич *****

-- Причины секционирования:
	1. Все данные в одном месте
	2. Идентичные смехы, индексы, компрессия (то есть у нас и архивные и оперативные данные вместе)
	3. Проблемы с поддержкой индексов
	4. Резервное копирование
	5. Восстановление после сбоев
	6. Проблемы со статистикой 

-- Недостатки
	1. Секционирование меняет план выполнения запросов
	2. Секционирование большого объёма данных долговременна и база будет заблокирована
	3. Увеличение стоимости разработки
	4. Увеличение объёма данных (если секционирование не по кластерному индексу, то к каждому некластерному
	   добавляется поле, по которому происходит разделение)
	5. Стоимость лицензий
	6. Потенциальные проблемы с Linked Servers
	7. Проблемы с уникальным ключом и Foreign Key

-- Преимущества
	1. Чуть более высокая производительность
	2. Разпределение нагрузки

-- Как мы можем секционирова данные
	1. Вертикальное секционирование

-- Смешанное секционирование (сервера разделены на секции представлений и таблиц, а основное представление этим управляет)
	- Получается динамическое создание секций и перемещений
	- Репликации, зеркалирование, AlwaysOn будет работать только в том случае, если структура баз и дисков
	  совпадает на всех серверах

-- Секционирование и файловые группы
	1. Что следует принять во внимаение
		- Стратерию восстановления
		- Ограничения в дисковой системе
	2. Связанные объекты
	3. Разделение между модифицируемыми и статичными объектами
		- Файловая группа со стат. объектами может быть помечена как Read Only

-- Посмотреть сколько строк в секциях таблицы
	select partition_id, partition_number, rows
	  from sys.partitions
	  where object_id = object_id ( N'dbo.Table_1', N'U' );
	go

-- Разбиение секции	10 и 100
	alter partition scheme ps_range_left
	next used [PRIMARY]; -- Куда будет помещена секция
	alter partition function pf_range_left() 
	split range (50); -- Добавляем новый диапазон, который разобьёт 10-50 и 50-100

-- Разбиение
	alter partition function pf_range_left()
	merge range (50);
	go	
	
-- I. Код Windows Asure
-- Создаём федерацию
	CREATE federation Fed(FID int range)
	GO
	ALTER federation Fed split at (fid = 100)
	GO

-- Смотрим созданные федерации
	SELECT * FROM sys.federations

-- Переключаемся в федерацию
	- Федерация это совершенно иная БД
	use federation Fed(fid=0) with reset, filtering = off

-- Чтобы работать с секциями, надо создать таблицу на их основе
	CREATE TABLE FedTable
	(
		ID int not null primary key,
		Val nchar(255)
	)
	federation on (fid=id) -- Теперь если захотим вставить в неё данные, то сможем вставить только с id < 100

-- Федерация в Windows Asure
	- Невозможно объединить данные из разных членов федерации в рамках одного запроса
	- Обход ограничений размера БД в 150 GB
	- Различные схемы данных в разных федераций
	
--***** Компрессия/COMPRESS *****
	- Не работает с ntext, nvarchar(max)

