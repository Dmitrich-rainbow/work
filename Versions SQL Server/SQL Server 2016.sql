Установка на Linux?
https://www.r-project.org/

http://aboutsqlserver.com/presentations/

Developer Edition бесплатна. Применить у нас

Изучить лучше in-memory + Native proc (machine code)

2016 позволяет alter index partition rebuild online

Если у вас на диске много индексов с большим набором столбцов или с включенными полями, то тут in-memory выиграет по месту.

+ не забывайте про фрагментацию на диске и неполное заполнение страниц. В памяти этой проблемы нет, поэтому данные будут занимать меньший объем. В среднем по статистике около 20-30% свободного места на диске в страницах.

Garbage Collector очищает неиспользуемые старые версии строк из памяти. Data + delta файлы очищаются, если они больше не используются, либо объединяются. Но, если у вас слишком большое количество изменений на таблицах, я бы рекомендовал очень осторожно использовать in-memory, т.к. для них обновления это опасный сценарий.

 К дисковому хранилищу требования такие, что у вас должен успевать записываться журнал транзакций, скидываться данные в data+delta файлы и успевать при старте сервера загружаться за нужное количество времени.
 
 Да, в последней июньской версии и даже раньше она доступна. Работает как с 2016 так и с 2014 версиями.(Live Query Statistics)


А как происходит откат транзакции в in-memory OLTP? удаление записей в Delta?
Записи от откатившихся транзакций не попадают в t-log и, соответственно, CFP. Они остаются в памяти и убираются GC. Ключевой момент - data/delta файлы содержат только закомиченные данные и работают как append-only файлы


На сколько эффективно использовать im-memory table в случае таблицы логирования действий с системой, если данная таблица = примерно 40% от всей БД?
Дмитрий, если говорим о производительности вставки в таблицу - зависит от частоты вставок. Вы избавляетесь от латчей - соответственно будет улучшение производительности. Вопрос в памяти - насколько уменьшение buffer pool повлияет на производительность. Я бы рекомендовал бы секционирование - наподобие того, о чем я буду говорить в третьей части доклада - новые вставки идут в memory-optimized таблицы, а потом данные переносятся на диск


Доброго дня. Тестировал инмемори табл переменные по сравнению  дисковыми табл на вставку (как потенциальную замену). Вставлялся один столбец int, переменные проседали после объёма вставки в 10000 строк (дисковые табл были лучше в несколько раз).
Дмитрий, тут сложно сказать. Очень все зависит от переменных - сколько одновременно работающих сессий (есть ли проблема с латчами во время доступа к странице). какая структура данных, итд. Если мы говорим о сценарии с одной сессией и записью в несколько байт - вы действительно большой разницы не увидите - у вас нет латчей, много записей на странице, небольшие записи в t-log. в реальной нагрузке картина изменится. скачайте примеры с http://aboutsqlserver.com/presentations - там в первом докладе был пример вставки в параллели - это ближе к реальной жизни и параллельной нагрузке


Добрый день. Не совсем понятно в какой момент проходит запись измененных таблиц из памяти на дисковую систему т.е. в файлы .mdf базы данных, это делается в фоне в порядке очереди или в памяти держатся только чистые не измененные данные, только чтение?.
Александр, In-Memory OLTP использует другую файловую группу для memory-optimized данных. Технология базируется на FILESTREAM и использует append-only паттерн. Запись в эти файлы происходит во время checkpoint (в in-memory oltp это отдельный процесс), который читает t-log и заполняет эти файлы



Сильно сомневаюсь, что узким местом является процессор...
Дмитрий, скажем так, In-Mem OLTP масштабируется и грузит процессоры почти до 100%. естественно в картине есть диск, но работа с ним оптимизирована для последовательного доступа. t-log, но при этом логгирование более оптимизировано по сравнению с дисковыми таблицами. Я имел в виду процессор потому что у нас нет латчей, что в OLTP в дисковых таблицах становятся узким местом.



Доброго времени. Как часто происходит checkpoint? Где лучше хранить файловые группы для memory-optimized? Отличный доклад!
Кирилл, спасибо! CHECKPOINT - работает постоянно. Он читает t-log и заполняет checkpoint file pairs (файлы в которых In-Mem OLTP хранит данные). Работа с дисками в In-Mem OLTP оптимизирована для последовательного доступа (в первую очередь последовательной записи) - так что кладите ее на диски, оптимизированные для этой нагрузки



timestamp передачи журнала на реплику

http://aboutsqlserver.com/presentations/

табличный параметр (проблемы с оценкой строк/статистика и bucketcount)?

-- AlwaysOn
	-- Балансировка:
		- Указать куда идут запросы на чтение
	-- Failover
		- Переезд когда БД стала недоступна (опция, которую надо включить)
	-- Домен
	-- Производительность
		- Полностью переработан механизм передачи данных на реплику (трансфер)
	
-- AlwaysEncryption
	-- Основное
		- Шифруется только часть столбцов
	-- Azure
		- Позволяет хранить там данные в зашифрованном виде, чтобы администратор сервиса не мог получить к ним доступ
		
		
-- In-memory
		Индексы на диске не хранятся и загружаются в момент старта системы
		записи в лог делаются только после commit
		- Узкое место процессор против дисков на обычных системах
		- CREATE TYPE (табличный вид) вместо временных таблиц. 
		- Табличные переменные как в памяти так и на диске работают примерно одинакого в плане оценки строк. В 2016 RECOMPILE позволяет оценить строки правильно
		- bucketcount лучше переоценить, чем недооценить