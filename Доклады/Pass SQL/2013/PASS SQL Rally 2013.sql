SQL Saturday (конференции в субботу)
sqlsaturday.com/219
sqlsaturday.com/178
Промокод на  RALLY13 http://www.sqlpass.org/summit/2013/

Интеграция с облаком - ?
AlwaysOn:
1. tempdb можно хранить локально - ?
OpenText Email Monitoring - ?
truncate table (очистка таблицы) - ?
табличная переменная - ?
InsertTime - ?
Колоночные индексы -?
Статистика tempdb (см 3 картинку)-?

SQL Server не умеет кэшировать результат выполнения запроса
Dynamic Managment Views
Процесс блокирует сам себя - 

Новые лицензии:
1. Можно на ядра

--I. Арсеений Бирюко. Развитие SQl Server:

Эволиция развития:

Смысл перехода:
1. Отказоустойчивость
2. Производительность
3. BI
4. Новые возможности

Высокая доступность:
1. 2000 (Log Shipping, Failover cluster (дорогая))
2. 2005 (+Mirroring(всё хорошо, но пользователей надо заводить самим))
3. 2012 (+AlwaysOn(Mirroring+Failover cluster))

BI:
2000(SSAS(простые)SSRS)
2005(SSAS(стал продвинутым),SSRS(немного улучшился))
2008(SSAS(улучшена производительность),SSRS(Tablix, диаграммы и т.д.))
2008R2(SSRS(данные на карте,KPI,Графики в табличке(спарклайны),PowerPivot)
2012(SSAS(2 режима - Олап и Мультименшион), PowerView для SharePoint(визуализация, которая обеспечивает ястность и простоту))

Производительность:
2005(Тонкое настраиваение индексов(индексированное представление, секционирование,Dynamic Managment Views(что происходит с сервером)))
2008(Фильтрованные индексы(создаётся для части строк таблицы), Сжатие данных(архивация и оптимизация типа))
2012(Columnstore)

Новые возможности:
2005(Связь с CLR...)
2008(Дополнительные типа данных...)
2012(Оконные функции...)

-- II Большой поток данных. Дмитрий Костылев. Лаборабория касперского:
Ключи успеха с работой BigData:
BigData - это такой момент когда у вас для восстановление есть 3 часа, а backup/restore = 4
1. Разделить читателей и писателей(ещё и между собой)
2. Подбирать размер данных, обрабатываемых за одну транзакцию
3. Разумные типа данных
4. Минимизируем время работытранзакции
5. Стараться добавлять данные, а не обновлять

	- То, что вставляем отделяем от того, что надо обновлять(2 разные таблицы)
	- Bulk insert (лучше вставлять большим объёмом, а не по 1 строке). В этом режиме, SQL не вставляет
	  в существующие страницы, а формирует свои страницы и потом подключает их к таблице за 1 операцию.
	  В новых версиях SQL иногда сам делает такие оперции в фоновом режиме. Можно даже в теле 1
	  транзакции сделать 10 вставок и это будет работать быстрее.
	  - Минусы:
	  Но если случится авария, то мы потеряем данные, поэтому возможно что надо снижать порции
	  данных. Так же при превышении како-то порога можем произойти замедление. Чем больше блокировок
	  в рамках 1 транзакции, тем больше шанс дедлока
	- Секционирование:
		- Пишем туда, куда не обращаются
		- Каждый писатель приходил в свой сегмент(секции). Например турникеты в метро, каждый
		  турникет - своя секция, чтобы не было лишних блокировок. Конвеер - пишем с одной
		  стороны, читаем с другой, то есть пишет в секцию, потом подключаем/объединяем к читающей таблице.
		  Ещё 1 метод - Помещаем данные, которые нужно удалить в секцию, потом подключаем секцию в
		  другое мето и там уже можно удалять уже всё (всё это происходит за 1 операцию)
	- Типы данных:
		- Чем меньше - тем лучше
		- Не использовать Max без нужды
		- Кластерный индекс по GUID -- Спорный вопрос
	- Сжатие данных
		- Снижает нагрузку на диск
		- Конфликт с шифрование и sparse столбцами
		- Менее эффективно добавлять данные по 1 строке в уже сжатые секции.(Пишем в несжатые секции,
		  сжимаем и переносим)
	- Диски
		- Raid 1 и 10. RAID 5 плох, особенно на малых операциях вставки/записи, даже хуже чем RAID 1 будет
		- Файлы данных и логов на разных дисках
		- Кэш можно полностью отдать на запись(если кэш контроллер хороший). Никакой Кэш контроллер
		  не сможет на чтение работать лучше SQL Server, 
	- Мелкие
		- Поставить везде Set nocount on во всех процедурах и триггерах
		- По возможности не использовать Триггеры. Увеличиваем время выполнения и блокировок
		- READPAST хинт(таблица, которыуюнадо обработать, а строки заблокированы, с этим хинтом можно
		  читать только те строки, которые не заблокированы)
		- Можно отключить эскалацию блокировок (но увеличиваем размер внутреннй табицы блокировок,
		  но увеличваем от этого нагрузку на процессор)

--III Управление памятью. Олонтсев Сергей
- Нужна для кэширования страниц, хранения планов, блокировок, состояний подключения, кэша журнала
- Память, чтобы выполнить сам запрос
- Для обработки потока данных
- Много памяти требуется чтобы обработать блокирующие операторы (Hash Match(ajoin aggregate), Sort,Gather Streams,Distribute Streams,Repartition)

- Как происходит Sort
	- Входящий поток, затем сортировка, потом поток идёт дальше
	- Обычно если забираем таблицу 100 мб, потрубется 200 мб, если нет памяти, то уйдёт в tempdb
- Hash Match
	- Вход. поток, к нему применяется hash-функция (даёт идентификатор), её задача эффективно разбить данные на несколько
	  блоков(хэш корзины), далее второй поток, к нему так же применяется hash-функция, далее для каждой
	  строки ищется нужное значение и результат уходит дальше

- Hash Bailout
	- Если всё хорошо, то всё уходит в памяти (In-memory)
	- Если всё плохо, то данные разбиваются на блоки и кладутся на диск и потом читаются(Grace Hash Join)
	- Если после того памяти не хватило, то происходит третий этап, который ещё хуже(Recursive Hash Join)

- Мониторинг ситуаций (см. 2 картинку)

- Память
	- Примерно 75% выделяется для запросов (Это можно изменить в Resource Governor)
	- Не более 18,85% всей памяти (Это можно изменить в Resource Governor)
	- Маленькие запросы лучше пропускать вперёд (Можно указать важность запроса, оценивается стоимость)
	- Лучше ожидать памяти или свалиться в tempdb?

- Resource semaphore (пропускает все запросы через себя) 
	- Маленький (не более 5 мб памяти)
	- Остальные большие
	
Concurrence & Timeouts
	- Пропускает вперёд маленькие и более важные запросы
	- Не позволяет отъесть все ресурсы сервера
	- Максимальнео время ожидания (query timeout) 

- Влияние на план выполнения (4 картинка)
- Мониторинг (5 картинка)
DBCC MEMORYSTATUS
- Статистика (6 картинка)

-- IIII Алексей Шуленин. SQL Server в облаке. Сравнение PaaS- и IaaS- подходов при внедрении.
