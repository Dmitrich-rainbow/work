-- *****  Реализация модели данных и отчетов с помощью Microsoft SQL Server 2012 *****


Самородов Федор
fedor@Samorodov.ru
http://Samorodov.SU
Фёдор Самородов
+7 916 159-57-84

OLAP - инженерное название

--Business Intelligence (BI)
Позволяет строить отчеты в реальном времени на большим объемах данных
Шаги:
1. Консолидация данных (собрать всю информацию в одном месте) в хранилище (обычная реляционная база данных), которое оптимизировано таким образом, чтобы быстро собрать туда данные. Делается с помощью SSIS
2. Переносим базу в многомерную базу (язык запросов MDX). Делается с помощью SSAS
3. Из результата запроса(SQL, MDX) получить отчёт и доставить до пользователя. Делается с помощью SSRS
 
-- Многомерные БД/SSAS
- Язык запросов тут - MXD
- Преимущества
1. Обрабатывать в реальном времени агрегировать огромное количество записей
2. Позволяют это делать для любых запросов
- Минусы
1. Куб медленно наполняется

- Многомерные БД строятся всегда по верх других бд, желательно по верх хранилища(бд постоенная по определённому принципу)
- Если обычная БД, хранит данные в строках, то многомерная - в кубах
- Куб быстрее делает Агригацию, потому что он уже построил их все на моменте создания. 
- Из Managment Studio невозможно создать многомерную базу, только управлять ей. Их создают в Vsual Studio
- Таблица фактов - та таблица, данные которой переедут во внутренности кубов(меры - то, что мы будем агрегировать, раскладывать). Таблица фактов измерением быть не должна

-- Процессинг (загрузка данных)
	- Его надо делать автоматически и в SSIS есть специальный таск

-- MDX
- Операции:
1. Сечение - можно резать плоскостью, которая перпендикулярна одной из осей (Это что-то типа условия WHERe)
2. Схлопывание/сжатие куба по одной из осей - сжимаем до квадрата (меньше данных, но они уже более ценные, это как GROUP BY + Aggregate)(Это что-то типа уменьшение выделяемых полей в SELECT)

-- Работа с многомерными базами в Visual studio
- Многомерные базы:
	- /*Логика*/
		1. Источник данных
			- Учетная запись
		2. Представление (Data Source Views):
			- Убрать лишнее
			- Добавить недостающее
		3. Измерения/Размерности:
			- /*Ключ измерения*/ (на шаге выбора полей измерения, надо указать в Key columns (в центре) значение, котрое укажет как отличать их между собой)
			- Лучше сначала сделать все измерения (Demensions), а потом уже строить куб, так будет удобнее
			- /*Атрибуты*/ (то что в реляционной базе было столбцом)
			- /*Ключи атрибутов*/ (в Properties нужного атрибута Source>Key Columns). Их надо указывать, когда у нас 5 разных готов и 12 месяцев
			  и мы хотим узнать информацию за каждый месяц каждого года. В таком случае в месяца ключ атрибута должен быть год+номер месяца 
			- /*Имена атрибутов*/ (в Properties нужного атрибута Source>Name Columns). Если это составной ключ атрибута, то и имя лучше сделать таким
			  же, для ясности. На прошлом примере это будет добавление вычисляемого поля в представляение(Год+ ' ' + Название месяца)
			- Не забывать про сортировку в Properties нужного атрибута
			- Если не достаточно одной таблицы в измерении, то можно добавить ещё любую другую в насройках измерения
			- /*Иерархия атрибутов*/ (то, из чего выбирает пользователь) Сервер строит иерархию сам, но можно и самому в настройках измерений, в центральной части
			- /*Отличие измерения от размерности*/
		4. Меры
			- Группы мер
			- Агрегатная функция
			- Связь с размерностями
		5. Куб
			- Когда строится куб, в мере может быть несколько дат, поэтому могут создаться дополнительные измерения
			- /*Количество измерений в кубе*/ Каждое измерение, что мы построили распадается на столько измерений, сколько атрибутов в нём	
			- Закладки куба
				- /*Dimension Usage*/ Прописано как именно связано измерение с фактической таблицей (мера). Хорошо если эта связь прямая,
				без посредников. Если мера на прямую не связана с измерением, то надо указывать посредника и ключи,
				которые связывают меру и нужное измерение.	
				- /*Calculation*/ Можно сохранять в кубе сохранять разнообразные объекты (как в SQL триггеры, view, процедуры):
					- /*Значек калькулятора*/ - инструкция WITH MEMBERS, искать надо в мерах
					- /*Значек круглых скобок*/ - инструкция SET в WITH или иначе набор. Искать надо в той иерархии, из который она состоит
				- /*KPI*/ Похоже на процедуру. Это сложный MDX запрос, который легко вызывается. Это самая минимальная форма отчета, это отчет,
					который сжат на столько, что представляет собой 1 число(хорошо/плохо). Она будет видна как мера, желательно делать так,
					чтобы она резалась по всем измерениям. 
					- Преимущества KPI перед меры:
						1. Более функциональная
					- Разделы
						- /*Value Expression*/ Основное выражение
						- /*Goal Expression*/ Превысил ли KPI указанное значение, чаще это вычисляемое поле
						- /*Status Expression*/ Выражение в стиле CASE END и можно опираться на 2 предыдущих поля
							CASE
								WHEN KPIValue("Sales per Unit") / KPIGoal("Sales per Unit") > 1.2
									THEN +1
								WHEN KPIValue("Sales per Unit") / KPIGoal("Sales per Unit") < 0.8
									THEN -1
								ELSE 0
							END 
				- /*Perspectives*/ Отключить ненужные части куба. Он подменяет куб и селект будет уже из перспективы. Нельзя раздавать права на них
				- /*Translations*/ Подмена названий на другой язык. Есть не только в кубе, но и в измерении
				- /*Actions*/ Работает, только если приложение о них знает. Их нельзя задейстовать через MDX. Это пункты в контекстном меню
	
	- /*Физика*/
		1. /*Связи атрибутов*/ /*Attribute Relationship*/ искать в измерениях. Позволяет серверу понять, как связаны иерархии друг
		с другом и если у них есть определённая связь, то серверу не надо считать множество агригаций. Нижняя правая часть - рабочая, 
		верхняя - лучше использовать как элюстрацию. Если мы сделаем ошибку при формировании связей,
		то сервер в момент запроса выдаст ошибку, если будут 2 одинаковых названия, то можно будет поменять либо ключ,
		либо переименовать эти названия Читать связи надо слева на право. Скажем "От дня зависит месяц, от месяца - год".
		2. /*Секции*/ /*Partitions*/ в кубе. Секционируется каждая группа мер
		3. /*Механизм хранения:*/ MOLAP, HOLAP, ROLAP (применяется к кубам, секциям и размерностям)
			1. MOLAP - настоящая многомерная БД. Информация забирается полностью из реляционной бд, всё считается и бд готова.
				Плюсы:
					- Самый быстрый
					- Хранилище не нужно
				Минусы:
					- Много занимает места
					- Если данные изменились, то в кубе мы не увидим данные до следующей загрузки
			2. ROLAP - имитация многомерной базы. Хранится структура куба, но каждый раз когда пишем MDX запрос,
			   он превтащается в t-sql и исполняется в хранилище			
				Плюсы:
					- Не тратим место
					- Актуальность
				Минусы:
					- Медленный, очень медленный
			3. HOLAP - компромиссный вариант. В многомерной базе хранятся агригации, но не детальный данные. Если запрос потребует
			   извление детальных данных, то полезем в реляционное хранилище
			4. Есть другие режимы, но на этом курсы мы их не изучили
 
		
- Data Source Views
1. Нужно чтобы абстрагироваться от ненужных таблиц
2. Можно доделать то, что вы не доделами в хранилище. Например добавить вычисляемые поля (T-SQL), делается это через пкм на
   добавленной таблице New Name Calculation. Так же можно добавить таблицу, но по сути это будет запрос, которые представляется таблицей,
   лучше делать всё это в хранилище(первоисточнике)
- После настройки куба, его надо опубликовать на сервере
- Если при развертывании приложения выскакивает непонятная ошибка, то первым делол проверить пароль на Data Source

-- Backup
	- пкм по базе > Свойства > Backup. Убрать голочку запроса пароля. Вообще backup хранится в 1 файле, а сама база хранится
	  во множестве файлов 
	  
-- Перенос сервера с тестовой базы на боевую
	- пкм по базе > Synchronize
	- можно сгенерировать сценарий развёртывания базы. В Visual Studio>Deploy OLAP (возможно надо будет ещё нажать Build OLAP)
      и в папке проекта, в bin появляется готовый для развертывания проект. Нужен тот файл, что большой и с .asdatabase.
	  Дальше разработчик отправляет этот файл администартору. Администратор получил файл и открывает в пуске
	  SQL SERVER>Analisys Services>Deployment Wizard, указываем вышеуказанный файл, отвечаем на вопросы и в самом конце мастер готоворит,
	  что программа сгенерирует скрипт, который можно запустить с форматом .xmla. Далее через managment studio открываем его через проект XMLa Query и запускаем
	  
-- MDX
- Если в t-sql на входе таблица и на выходе таблица, то в mds и там и там куб.
- /*Вопросы, на которые надо ответить, чтобы построить стоящий запрос в mdx:*/
	1. Что будет по горизонтали (может быть больше 1 измерения, но студия этого не покажет) --[Geography].[Country].Members ON COLUMNS
	2. Что будет в виде строк (может быть больше 1 измерения, но студия этого не покажет)-- [Order Date].[Calendar Year].Members ON ROWS
	3. Что будет в ячейках (в центре)(срез). Если не указана мера, то он берёт меру по-умолчанию - самую верхнюю -- WHERE [Measures].[Sales Amount]
- Пример запроса
SELECT
	[Product].[Color].Members ON COLUMNS,
	[Order Date].[Month].Members ON ROWS	
FROM Sales
WHERE [Measures].[Sales Amount]

- Если мы хотим чтобы не было выбрано колонок
SELECT		
{} ON COLUMNS,
[Geography].[Country].Country ON ROWS
FROM Sales

- Можно представить, что мера это ещё одна плоскость в кубе, тогда нам будет легче строить запросы, можно даже построить вот так
SELECT		
[Measures].[Order Quantity] ON COLUMNS,
[Geography].[Country].Country ON ROWS
FROM Sales

- /*Структура запроса*/
[Размерность].[Иерархия].[Уровень].[Член] ON COLUMNS
[Geography].[Country].Country.[Russia] -- Тут указано название
[Geography].[Country].Country.&[8] -- Тут указан ключ, часто совпадает с названием. Может быть несколько &, если ключ составной


- /*Функции*/
	- Структура
		1. Функция(аргумент)
		2. Аргумент.Функция
		3. Аргумент.Функция (параметры)
- [Размерность].[Иерархия].Members (показывает все члены иерархии)

- /*Множества/перечисления*/ Это перечисление однотипных элементов, которые взять с одной иерархии. Здесь упорядоченные элементы
	- Надо использовать {}, всё что в них это множества
		SELECT
		{		
		[Measures].[Order Quantity],
		[Measures].[Order Quantity - Fact Reseller Sales]
		} ON COLUMNS,
		[Geography].[Country].Country ON ROWS
		FROM Sales
	- Если хотим вытащить конкретные, скажем, города, то надо сделать вот так
		SELECT
		{		
		[Measures].[Order Quantity],
		[Measures].[Order Quantity - Fact Reseller Sales]
		} ON COLUMNS,
		{
		[Geography].[City].&[Berlin], -- & - ампесант (обращение по первичному ключу)
		[Geography].[City].&[London],
		[Geography].[City].&[Paris]
		}
		 ON ROWS
		FROM Sales

- /*Кортеж*/
	() кортеж - набор координат, которые взять с одной иерархии
	
	SELECT
	(
	[Customer].[Gender].&[M],
	[Product].[Color].&[Blue]
	) ON COLUMNS
	FROM Sales
	WHERE [Measures].[Sales Amount] -- В результате получим на 1 оси всё это
	
	- Сочетание кортежа и множества, но тут важны правила
		1. Кортежи должны быть однотипны
		2. Не надо в один кортеж сувать и мужчин и женщин
		SELECT
		{
		(
		[Customer].[Gender].&[M],
		[Product].[Color].&[Blue]
		),
		(
		[Customer].[Gender].&[F],
		[Product].[Color].&[Red]	
		)
		}	ON COLUMNS
		FROM Sales
		WHERE [Measures].[Sales Amount] 

	- Так же кортежи можно использовать в Мерах
		SELECT
		{
		(
		[Customer].[English Country Region Name].&[Germany],
		[Customer].[Gender].&[M],
		[Product].[Color].&[Red]
		),
		(
		[Customer].[English Country Region Name].[France],
		[Customer].[Gender].&[F],
		[Product].[Color].&[Blue]
		)
		}
		ON COLUMNS
		FROM Sales
		WHERE (
		[Measures].[Sales Amount],
		[Order Date].[Calendar Year].&[2008]
		)

- /*Иерархия*/ Расположена на размерности и по ней можно использовать навигацию. Основное преимущество многомерной базы
	-/*Parent*/ Показывает родителя. Поднимается на верх иерархии
	SELECT
	{} ON COLUMNS,
	[Product].[Hierarchy].[English Product Name].[Chain].Parent.Parent ON ROWS
	FROM Sales
	- /*Children*/ Показывает потомков. Опускается вниз по иерархии
	- /*Siblings*/ Браться и сёстры элемента.
	- /*PrevMember*/ предыдущий элемент. Упорядочены не по именам
	- /*NextMember*/ следующий элемент
	- /*Диапазон/Range*/ Диапазон между элементами
	SELECT
	 {} ON COLUMNS,
	 {
	 [Geography].[Hierarchy].[City].[Malabar]
	 :
	 [Geography].[Hierarchy].[City].[Wollongong]
	 } ON ROWS
	FROM Sales
	
	- /*Cousin*/ Двоюрдный брат, который является потомком текущего родителя
	SELECT
	 {} ON COLUMNS,
	 Cousin	 (
	 [Geography].[Hierarchy].[City].[Malabar],
	 [Geography].[Hierarchy].[Country].[France]
	 ) ON ROWS
	FROM Sales
	
	- /*Ancestors*/ Перепрыгивать через указанное количество уровней, чтобы не писать несколько раз Parent
	SELECT
	 {} ON COLUMNS,
	 Ancestors	 (
	 [Geography].[Hierarchy].[City].[Malabar],
	 2
	 ) ON ROWS
	FROM Sales
	
	-/*Descendants*/ Потомки на указанное количество уровней вниз. Если указать без цифры, то будут выведены все потомки
	SELECT
	 {} ON COLUMNS,
	 Descendants(
	  [Product].[Hierarchy].[Subcategory].[Gloves],
	  2
	  ) ON ROWS
	FROM Sales
	
	-/*ParallelPeriod*/ Хорошая замена Cousin,Ancestors,Descendants
	WITH	
	MEMBER Measures.PrevPeriod
		AS 
		(ParallelPeriod (
			[Order Date].[Hierarchy].[Calendar Year], -- По чему делаем паралел(год),
			1, -- Сколько отнимаем от текущего. Положительное число - смотрим в прошлое, если отрицательное - в будущее
			[Order Date].[Hierarchy].CurrentMember -- Текущий месяц
							),
			[Measures].[Order Quantity]
							)
	SELECT
	{
	[Measures].[Order Quantity],
	Measures.PrevPeriod
	}
	ON COLUMNS,
	[Order Date].[Hierarchy].[Month]
	ON ROWS
	FROM Sales
	
		
- /*Filer*/ (какое поле фильтруем, условие)
SELECT
	{} ON COLUMNS,
	FILTER(
			[Customer].[English Country Region Name].[English Country Region Name],
			(
			[Order Date].[Calendar Year].[Calendar Year].[2006],
			[Measures].[Sales Amount]
			)
			>
			(
			[Order Date].[Calendar Year].[Calendar Year].[2007],
			[Measures].[Sales Amount]
			)			
			) ON ROWS
FROM Sales	

- /*Order*/ (поле, условие, какая сортировка)
SELECT 
	[Measures].[Order Quantity] ON COLUMNS,
	ORDER (
			[Customer].[City].[City],
			(
				[Measures].[Order Quantity]
			),
			DESC
		  ) ON ROWS
FROM Sales	
	
- /*CrossJoin*/ (чтобы вывести более 2-х сущностей, при этом они отображаются в строчку)
SELECT
	 CROSSJoin
	 (
     [Geography].[Country].[Country], 
	 [Order Date].[Calendar Year].[Calendar Year]
	 )  ON COLUMNS
FROM Sales
WHERE [Measures].[Sales Amount]

	- или
	
SELECT
	 (
     [Geography].[Country].[Country], 
	 [Order Date].[Calendar Year].[Calendar Year]
	 )  ON COLUMNS
FROM Sales
WHERE [Measures].[Sales Amount]

- /*WITH*/
	- В селекте мы можем использовать только многомерные команды, а всё остальное надо выносить в WITH
WITH
	MEMBER Measures.[Total] -- Member это мера, вроде как
		AS
			[Measures].[Order Quantity]+[Measures].[Order Quantity - Fact Reseller Sales]
	SET Europe
		AS {
			[Geography].[Hierarchy].[Country].&[France],
			[Geography].[Hierarchy].[Country].&[Germany],
			[Geography].[Hierarchy].[Country].&[United Kingdom]
			}
SELECT
	Europe ON COLUMNS
FROM Sales
WHERE Measures.[Total]

- /*CurrentMember*/
	- Применяется к иерархии
	WITH
	MEMBER Measures.[Total]
		AS
			(
				[Order Date].[Hierarchy].CurrentMember.Parent,-- Берём текущий элемент и его родителя и выводим его [Order Quantity]
				[Measures].[Order Quantity]
			)
	MEMBER Measures.[Total One]
	AS
		(
			[Order Date].[Hierarchy].CurrentMember,
			[Measures].[Order Quantity]
		)
		/ -- Деление
		(
			[Order Date].[Hierarchy].CurrentMember.Parent,
			[Measures].[Order Quantity]
		)
	SELECT
		{
		[Measures].[Order Quantity],
		Measures.[Total],
		Measures.[Total One]
		} ON COLUMNS,
		[Order Date].[Hierarchy].[Month]
		ON ROWS
	FROM Sales
	

-- Аналог SSAS (Табличные данные/Табличные модели данных). Есть только в 2012 версии и не во всех редакциях и он назвал это Vertipaq
- /*Колоночные СУБД*/Данные укладываются не по строчно, а по столбцам. При этом тут по-умолчанию включено сжатие, которое сжимает
  данные так, что хранится количество уникальных записей(значений 10 - 500 шт). Благодаря этому, место занимает такой индекс мало
- Чтобы вывести пользователю строку, реллеационный механизм поднимает из механизма хранения всего лишь одну, непрерывную часть файла
  в память. Потому что данные в релиационном механизме уложены по строчно
- Чтобы вывести пользователю 1 стобец, то приходится поднимать в память больше данных, чем нужно (поднимаем все столбцы),
  но не использовать их. 
- Табличная модель это то же отдельная служба, а как дополнение есть табличные индексы в многомерной базе, физика там как и
  у табличной модели
- /*Недостатки:*/
	1. Делает таблицу Read Only. Решение
		- Первый способ - когда вставляем данные, мы отключаем этот индекс, далее мы его ребилдем
		- Второй способ - с помощью секционирования (найти самому)
	2. Такой индекс можно сделать только 1 для таблицы, но в него можно включить многое. Просто добавляем колонки тупо, сервер сам всё распихает
	3. Есть смысл использовать только на Базах Хранилищах
	4. Если он не помещается в памяти, то он помещается на диск, а распаковывать на диске его очень долго и смысла от него нет
	5. Меньший функционал по сравнению с многомерными
	6. Нет связи многие ко многим
- /*Плюсы*/
	1. Быстродействие
	2. Его можно поднять в память и хранить там
	3. Легко создавать

-- Установка
- В момент установки нас спрашивают какой режим поставить:
	1. Multidimensional (стандартный SSAS)
	2. Tabular (Табличные данные)
- Эти службы не совместимы, надо ставить разные экземпляры

-- Табличный проект
- Разрабатывается сразу на сервере. СОздаётся настоящая база, где и ведётся разработка
- Когда будем делать развертывание, то будут просто копируются данные в нормальную базу

- /*Настройка:*/
	1. Строится по верх существующей базы, лучше бд-хранилище
	2. Model -> Import form Datasource и настраиваем откуда будем брать и что. После этого происходит вставка данных
	3. Если надо поменять настройки подключения - сверху Esisting Connections
	4. Переключаемся в режим диаграммы(справа-снизу, картинка диаграммы). Если надо посмотреть все связи сразу - Table ->Manage Relationship
	5. В текущей версии такая база менее функциональна чем SSAS Multidimensional и что мы находимся в реляционной базе
	6. Неприятная особенность. Есть активные и не активные ключи между таблицами, в один момент времени, между двумя таблицами,
       можно делать активным только один из них. Выход:
		- Первый способ - если надо делать срезы по нескольким ключам, то ещё раз импортируем таблицу, но с другим именем Model -> Import form Datasourc.
		  Внешний ключ можно создать простым перетаскиванием. Но этот способ плохой, потому что происходит дублирование памяти
		- Второй способ - надо использовать dax в запросе
	7. Создание /*Вычисляемого столбца*/. Тут пишем на языке DAX(Экселевский язык формул). Переключаемся на табличный вид,
	   добавляем столбец и пишем формулу(=[FirstName]&" "&[LastName]), Получим ФИО
	8. /*Добавление фильтра*/ В табличном виде, стрелочка вниз около каждого столбца
	9. /*Создание мер*/ В центрельном верхнем меню кнопка суммы или Show Measure Grid, это отображает доп поля внизу таблицы и под нужным 
	   столбцом можно поставить курсор и начать там писать формулу. Total Sales: = Sum([SalesAmount]). Total Sales: - это название меры.
	10. /*KPI*/ - здесь это надстройка над мерами. Ставим курсор на меру и нажать кнопку по центру сверху "Create KPI". Сначала указана
    	мера, потом следующий выбор как в многомерной базе KPI Goal, далее ползунком следующее поле.
	11. /*Иерархия*/ здесь мони менее функциональны, чем в многомерных базах. Сначала находим таблицу в режиме диаграммы и там есть
    	кнопка "Create Hierarchies". Иерархия привязывается к таблице, то есть можно собрать иерархию только из одной таблице.
		Чтобы добавить в неё стобцы, просто перетаскиваем из таблицы, но если мы всё-таки хотим использовать и другие таблицы,
		то надо искусственно создать нужные вычисляемые колонки в этих таблицах (=RELATED(DimProductCategory[Name]))
	12. /*Perspectives*/ Перспективы. Кнопка на главной панели. Работает так же как в многомерной базе
	13. /*Partitions*/ Секции. Можно секционировать всё что угодно. Обычно это делается с целью более лучшего процессинга по дате или
	    по таблицам. Что-то вроде инкрементального процессинга в реляционной базе. Выбираем таблицу, содаём секции, нажимаем на значек
		SQL и пишем в каждую секцию свой запрос. Чтобы сделать процессинг только этой таблицы или Секции - Model -> Precess ->
		-> Выбираем секцию или таблицу. Так же это можно выбрать через Managment Studio
	13. /*Режим хранения*/. В свойстве проекта в VS. In-Memory аналог MOLAP, DirectQuery - аналог ROLAP. Но мы должны определиться сразу,
        так как DirectQuery многое не поддерживает и переключиться в него позже будет невозможно. DirectQuery Есть смысл включать когда
		в памяти не помещается сама табличная модель. При In-Memory вся база хранится в памяти, после перезагрузки автоматически
		подсасывается
	14. /*Роли*/ Настройка доступа пользователям. Разрешение с точностью до строк, а на ячейку нельзя. Сначала перечисляем все роли,
	    потом указывам Permissions, далее в DAX Filter пишем логическое выражение(должно возвращать true/false)(Year = 2004)
	15. /*Тестирование*/ Нажимаем кнопку анализировать в Excel, выбираем роль и тестируем
	13. После настройки, размещаем
	14. Дальше даём базу пользователю и он будет писать MDX запросы через Managment Studio. Для пользователя она выглядит как
	   полноценная многомерная база.

- /*Отличия SSAS Tabular от SSAS Multidimensional*/
- Пользователь в любом случае пишет запрос на MDX, но если это полноценная многомерная база (UDM), то этот MDX так и выполняется,
  а если табличная, то используется системой DAX. Эта система и называется BISM. А разработчик разработчик в многомерной схеме будет всё
  писать на MDX, а в табличной на более простом языке - DAX
- Программа, которая работает с данными базами, разницы между ними не увидит и даже Profiler даже этого не увидит

-- Выбор между SSAS Tabular и SSAS Multidimensional
	- /*SSAS Tabular*/
		1. Быстрое развертывание
		2. Простота
		3. Майкросовт даёт понять что именно за этим будущее
		4. Табличную модель мы не будем создавать в VS, все табличные модели мы будем конертировать из PowerPivot.
		   Не мы создаём табличные модели, а пользователи. Создают, тестируют, ловят ошибки, потом приходим мы,
		   берём файл и конвертируем в Tabular его на сервере. Пользователи должны быть продвинутыми, чтобы пользоваться PowerPivot
	
	- /*SSAS Multidimensional*/
		1. Более больший функционал
		
-	Если пользователи могут создать табличную модель - то она, если нет - тогда мы сами SSAS Multidimensional.		
		
-- PowerPivot
	- Устанавливается доп. плагином в Excel. Это реальный движок табличной модели, который работает так же быстро
	- Работа с ним:
		1. Запускаем модуль
		2. Подключаемся к базе
		3. Далее так же как и в Visual Studio
		...
		5. Чтобы увидеть отчет - PivotTable или что-то другое в том же меню
		6. Кнопка Refresh(начинается Processing)
		7. Как мы всё настроили, просто сохраняем в Excel файле и передаём дугим этот файл. У них всё то же самое
		
-- Импорт из PowerPivot в SSAS
	1. Открываем VS
	2. Проект Import from PowerPivot
	3. Указываем xlsx файл
	4. Книга превращается в модель
	5. Доделываем её
	6. Обновляем пароль к базе(подключение)
	7. Размещаем в SSAS
	8. Далее обращаемся к пользователям и говорим не трогайте больше файл xlsx, а делай так:
		- Открывай Excel -> Data -> Get External Data -> From SSAS -> Подключаем к серверу -> Выбираем куб

6 видео 02:32:44